<!-- Veltrax Diagram -->
<section class="vx-wrap">
  <div class="vx-bar">
    <label class="vx-toggle">
      <input id="modeSwitch" type="checkbox" />
      <span>Use DMZ relay</span>
    </label>
    <button id="ingest" class="vx-btn" type="button">Simulate ingestion</button>
    <span id="modeLabel" class="vx-mode">Mode: Air‑gapped (manual signed packages)</span>
  </div>

  <svg class="canvas" viewBox="0 0 1400 720" preserveAspectRatio="xMidYMid meet" aria-label="Veltrax data flow">
    <defs>
      <linearGradient id="grad" x1="0" x2="1" y1="0" y2="0">
        <stop offset="0" stop-color="#6ba4ff" stop-opacity="0.55"/>
        <stop offset="1" stop-color="#6ba4ff" stop-opacity="0"/>
      </linearGradient>
      <marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
        <path d="M0,0 L12,6 L0,12 Z" fill="currentColor" />
      </marker>
      <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur stdDeviation="6" />
      </filter>
    </defs>
    <g id="edges"></g>
    <g id="nodes"></g>
  </svg>
</section>
/* ——— Veltrax diagram styling ——— */
.vx-wrap { width:100%; max-width:1200px; margin:0 auto; }
.vx-bar { display:flex; gap:.75rem; align-items:center; justify-content:flex-start; margin:0 0 .75rem 0; flex-wrap:wrap; }
.vx-toggle input { margin-right:.5rem; }
.vx-btn { padding:.45rem .8rem; border:1px solid #2C2F36; border-radius:.55rem; background:#1B1D23; color:#E6E7EB; cursor:pointer; }
.vx-btn:hover { border-color:#4C8DFF; }
.vx-mode { color:#9AA3B2; font-size:.9rem; }

.canvas { width:100%; height:auto; display:block; background:transparent; }

.edge { stroke:#6b7a90; stroke-width:2.25; fill:none; marker-end:url(#arrow); }
.edge.glow { stroke:#9db7ff; }
.cap { font: 13px/1.25 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; fill:#E6E7EB; }
.cap-bg { fill:#0f1320; opacity:.92; rx:6; ry:6; }

.vn rect { fill:#121622; stroke:#2C2F36; stroke-width:1.25; rx:14; ry:14; }
.vn .ring { stroke:url(#grad); stroke-width:2; fill:none; opacity:.35; }
.vn .title { font: 600 18px/1.2 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; fill:#E6E7EB; }
.vn .b { font: 14px/1.45 Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; fill:#C8CFDA; }

@media (max-width: 860px) {
  .vx-mode{display:block; width:100%}
  .cap { font-size:12px; }
  .vn .title { font-size:17px; }
  .vn .b { font-size:13px; }
}
<script>
// ── 0) Config: layout + typographic rhythm ─────────────────────────
const PAD = 18;            // inner padding
const GAP_X = 80;          // horizontal gap between columns
const GAP_Y = 26;          // vertical gap inside node
const LINE = 20;           // bullet line height
const MIN_W = 300;         // min card width desktop
const MIN_H = 110;         // min card height (grows with text)
const MOBILE_BREAK = 860;  // stack diagram under this width

// ── 1) Data model (unchanged content, clearer wording where needed) ─
const model = {
  profile: "airgapped", // "airgapped" | "dmz"
  nodes: [
    { id:"cloud", col:0, row:0, w:320,
      title:"Cloud Sources",
      bullets:[
        "Vendor APIs • S3 • SaaS exports",
        "Signed bundles — staged in DMZ"
      ]},
    { id:"local", col:0, row:1, w:320,
      title:"Local Sources",
      bullets:[
        "Oracle • Postgres • SFTP • CSV",
        "Read‑only credentials • checksums"
      ]},
    { id:"dmz", col:1, row:0, w:320,
      title:"DMZ Update Agent",
      bullets:[
        "Signed pull & staging",
        "Pull → verify • no secrets at rest"
      ]},
    { id:"core", col:2, row:0, w:330,
      title:"Veltrax Core",
      bullets:[
        "Apps: Finex • Échelon • Verdict",
        "Postgres (local) • Local LLM engine"
      ]},
    { id:"roi", col:2, row:1, w:330,
      title:"ROI & Audit",
      bullets:[
        "Live savings & revenue",
        "JSONL → CSV/PDF • Immutable hashes"
      ]}
  ],
  edges: [
    { from:"cloud", to:"dmz",
      caption:{dmz:"Pulled over mTLS", airgapped:"Carried via signed media"} },
    { from:"local", to:"core",
      caption:{dmz:"Direct read‑only sync", airgapped:"Direct read‑only sync"} },
    { from:"dmz",   to:"core",
      caption:{dmz:"Verified → apply", airgapped:"Verify in staging → apply"} },
    { from:"core",  to:"roi",
      caption:{dmz:"Local logs → ROI/Audit", airgapped:"Local logs → ROI/Audit"} }
  ]
};

// ── 2) DOM refs ─────────────────────────────────────────────────────
const svg = document.querySelector('.canvas');
const gEdges = document.getElementById('edges');
const gNodes = document.getElementById('nodes');
const modeSwitch = document.getElementById('modeSwitch');
const modeLabel  = document.getElementById('modeLabel');
const ingestBtn  = document.getElementById('ingest');

// ── 3) Text wrapping helper (SVG tspans by measured width) ─────────
function wrapIntoTspans(textEl, text, maxWidth, lineHeight) {
  // Clear previous
  while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
  const words = text.split(/\s+/);
  let line = [];
  let tspan = document.createElementNS(svg.namespaceURI, 'tspan');
  tspan.setAttribute('x', textEl.getAttribute('x'));
  tspan.setAttribute('dy', 0);
  textEl.appendChild(tspan);

  for (let i = 0; i < words.length; i++) {
    line.push(words[i]);
    tspan.textContent = line.join(' ');
    if (tspan.getComputedTextLength() > maxWidth) {
      line.pop();
      tspan.textContent = line.join(' ');
      line = [words[i]];
      tspan = document.createElementNS(svg.namespaceURI, 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      tspan.setAttribute('dy', lineHeight);
      tspan.textContent = words[i];
      textEl.appendChild(tspan);
    }
  }
  // Return total height used
  const spans = [...textEl.querySelectorAll('tspan')];
  return Math.max(lineHeight, spans.length * lineHeight);
}

// ── 4) Layout calculation (grid on desktop, stacked on mobile) ─────
function computeLayout() {
  const w = svg.getBoundingClientRect().width || 1200;
  const isMobile = w < MOBILE_BREAK;

  // Columns and positions
  const colCount = isMobile ? 1 : 3;
  const colWidth = Math.max(MIN_W, Math.min(380, (w - (GAP_X*(colCount-1))) / colCount));
  const x0 = (w - (colCount*colWidth + (colCount-1)*GAP_X)) / 2;

  // Assign x based on column; y based on row (desktop) or flow (mobile)
  let yFlow = 30;
  model.nodes.forEach(n => {
    n.w = colWidth;
    if (isMobile) {
      n.x = x0;
      n.y = yFlow;
      // height calculated later; we just reserve space now
      yFlow += 180; // provisional, refined after text measurement
    } else {
      n.x = x0 + n.col*(colWidth + GAP_X);
      n.y = 140 + n.row*220;
    }
  });

  return { isMobile };
}

// ── 5) Edge path helper (nice cubic that never overlaps labels) ────
function curve(ax, ay, bx, by) {
  const dx = Math.max(60, (bx - ax) * 0.35);
  const c1x = ax + dx, c1y = ay;
  const c2x = bx - dx, c2y = by;
  return `M${ax},${ay} C${c1x},${c1y} ${c2x},${c2y} ${bx},${by}`;
}

// ── 6) Draw routine ────────────────────────────────────────────────
function draw() {
  gEdges.innerHTML = ''; gNodes.innerHTML = '';

  const { isMobile } = computeLayout();

  // First pass: draw nodes to measure dynamic heights
  const tempGroup = document.createDocumentFragment();

  model.nodes.forEach(n => {
    const g = document.createElementNS(svg.namespaceURI, 'g');
    g.setAttribute('class','vn');
    g.setAttribute('tabindex','0');
    g.setAttribute('role','button');
    g.setAttribute('aria-label', n.title);

    // Base rect (height provisional → will be updated after wrapping)
    const r = document.createElementNS(svg.namespaceURI,'rect');
    r.setAttribute('x', n.x); r.setAttribute('y', n.y);
    r.setAttribute('width', n.w); r.setAttribute('height', MIN_H);
    g.appendChild(r);

    // Title
    const t = document.createElementNS(svg.namespaceURI,'text');
    t.setAttribute('x', n.x + PAD);
    t.setAttribute('y', n.y + PAD + 2);
    t.setAttribute('class','title');
    t.textContent = n.title;
    g.appendChild(t);

    // Bullets (wrapped inside width)
    let yCursor = n.y + PAD + 8 + 22; // title + spacing
    const maxTextWidth = n.w - (PAD*2) - 10;

    n.bullets.forEach((line, idx) => {
      const dot = document.createElementNS(svg.namespaceURI,'text');
      dot.setAttribute('x', n.x + PAD);
      dot.setAttribute('y', yCursor);
      dot.setAttribute('class','b');
      dot.textContent = '• ';
      g.appendChild(dot);

      const txt = document.createElementNS(svg.namespaceURI,'text');
      txt.setAttribute('x', n.x + PAD + 14);
      txt.setAttribute('y', yCursor);
      txt.setAttribute('class','b');
      const used = wrapIntoTspans(txt, line, maxTextWidth, LINE);
      g.appendChild(txt);

      yCursor += used + (idx === n.bullets.length-1 ? PAD : 6);
    });

    // Now set the real height
    const h = Math.max(MIN_H, yCursor - n.y);
    r.setAttribute('height', h);
    n.h = h;

    // Glow ring (under)
    const ring = document.createElementNS(svg.namespaceURI,'rect');
    ring.setAttribute('x', n.x-6); ring.setAttribute('y', n.y-6);
    ring.setAttribute('width', n.w+12); ring.setAttribute('height', h+12);
    ring.setAttribute('rx', 18); ring.setAttribute('ry', 18);
    ring.setAttribute('class','ring');
    g.insertBefore(ring, r);

    tempGroup.appendChild(g);
  });

  gNodes.appendChild(tempGroup);

  // If mobile, recompute vertical flow with actual heights to keep spacing tidy
  if (computeLayout().isMobile) {
    let y = 30;
    model.nodes.forEach(n => {
      n.y = y;
      const rect = [...gNodes.querySelectorAll('g.vn')][model.nodes.indexOf(n)].querySelector('rect:nth-of-type(2)');
      rect.setAttribute('y', n.y);
      const ring = [...gNodes.querySelectorAll('g.vn')][model.nodes.indexOf(n)].querySelector('rect.ring');
      ring.setAttribute('y', n.y-6);
      // shift all text children by delta
      const delta = n.y - (parseFloat(rect.getAttribute('y')) || n.y);
      const texts = [...[...gNodes.querySelectorAll('g.vn')][model.nodes.indexOf(n)].querySelectorAll('text')];
      texts.forEach((tx,i)=>{
        // Reposition by computing current and adding delta
        const y0 = parseFloat(tx.getAttribute('y')) || 0;
        if (y0) tx.setAttribute('y', y0 + (delta||0));
        // Move tspans
        tx.querySelectorAll('tspan').forEach((sp,si)=>{
          if (si===0) sp.setAttribute('dy', 0); // first line explicit
        });
      });
      y += n.h + 22;
    });
  }

  // Edges (under nodes, so they render first)
  model.edges.forEach(e => {
    const a = model.nodes.find(n => n.id===e.from);
    const b = model.nodes.find(n => n.id===e.to);
    const start = { x: a.x + a.w, y: a.y + a.h/2 };
    const end   = { x: b.x,       y: b.y + b.h/2 };

    const p = document.createElementNS(svg.namespaceURI,'path');
    p.setAttribute('d', curve(start.x, start.y, end.x, end.y));
    p.setAttribute('class','edge');
    gEdges.appendChild(p);

    // Caption with background chip (never cut off)
    const capGroup = document.createElementNS(svg.namespaceURI,'g');
    const cap = document.createElementNS(svg.namespaceURI,'text');
    cap.setAttribute('class','cap');
    const label = e.caption[model.profile] || '';
    cap.textContent = label;

    // Put it at curve midpoint
    const midX = (start.x + end.x)/2;
    const midY = (start.y + end.y)/2;

    cap.setAttribute('x', midX);
    cap.setAttribute('y', midY - 8);
    cap.setAttribute('text-anchor','middle');

    // background rect sized to text bbox after we insert it
    capGroup.appendChild(cap);
    gEdges.appendChild(capGroup);

    // After the text is in the DOM, measure and draw bg
    requestAnimationFrame(()=> {
      const bb = cap.getBBox();
      const pad = 6;
      const bg = document.createElementNS(svg.namespaceURI,'rect');
      bg.setAttribute('class','cap-bg');
      bg.setAttribute('x', bb.x - pad);
      bg.setAttribute('y', bb.y - pad);
      bg.setAttribute('width', bb.width + pad*2);
      bg.setAttribute('height', bb.height + pad*2);
      capGroup.insertBefore(bg, cap);
    });
  });
}

// ── 7) Interactions (mode + pulse) ─────────────────────────────────
modeSwitch.addEventListener('change', ()=>{
  model.profile = modeSwitch.checked ? 'dmz' : 'airgapped';
  modeLabel.textContent = modeSwitch.checked
    ? "Mode: DMZ relay (signed pull over mTLS)"
    : "Mode: Air‑gapped (manual signed packages)";
  draw();
});

ingestBtn.addEventListener('click', ()=> pulse());

let rafId = 0, t0 = 0;
function pulse(){
  stopPulse();
  const paths = [...gEdges.querySelectorAll('path.edge')];
  paths.forEach(p=>p.classList.add('glow'));
  t0 = performance.now();
  const tick = (t)=>{
    const k = (t - t0) / 700;
    paths.forEach((p,i)=>{
      p.setAttribute('stroke-dasharray','6 12');
      p.setAttribute('stroke-dashoffset', String(60 - ((k*60)+(i*10))%60));
    });
    rafId = requestAnimationFrame(tick);
  };
  rafId = requestAnimationFrame(tick);
  setTimeout(stopPulse, 3000);
}
function stopPulse(){
  cancelAnimationFrame(rafId);
  gEdges.querySelectorAll('path.edge').forEach(p=>{
    p.removeAttribute('stroke-dasharray');
    p.removeAttribute('stroke-dashoffset');
    p.classList.remove('glow');
  });
}

// ── 8) Resize observer: keep it crisp & responsive ─────────────────
new ResizeObserver(()=> draw()).observe(document.querySelector('.vx-wrap'));

// Initial render
draw();
</script>

